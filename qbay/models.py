import re
from email_validator import validate_email, EmailNotValidError
from datetime import datetime
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
import os

app = Flask(__name__)
# allow the app to use different database
db_string = os.getenv('db_string')
if db_string:
    app.config['SQLALCHEMY_DATABASE_URI'] = db_string
else:
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///qbayDB.db'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# User class


class User(db.Model):
    # User attributes
    __tablename__ = "user"
    # userId is the primary key used for ensuring record uniqueness in the db.
    # Should be autogenerated upon insert
    userId = db.Column(db.Integer, primary_key=True)
    # First name of user
    userFirstName = db.Column(db.String(50))
    # Last name of user
    userLastName = db.Column(db.String(50))
    # System username
    user_name = db.Column(db.String(20), unique=True, nullable=False)
    # User account password
    password = db.Column(db.String(20), nullable=False)
    # User email for registration and communication
    email = db.Column(db.String(320), unique=True, nullable=False)
    # User shipping address
    shipping_address = db.Column(db.String(200))
    # User postal code
    postal_code = db.Column(db.String(7))
    # User Canadian dollar balance
    balance = db.Column(db.Float, default=100)
    # User creation date
    dateCreated = db.Column(db.DateTime, nullable=False,
                            default=datetime.utcnow)
    # User transaction relationship
    transaction = db.relationship(
        'Transaction', backref=db.backref('transaction', lazy=True))

    # User Review relationship One to One
    review = db.relationship("Review", back_populates="user", uselist=False)

    # User methods

    # Create a new user
    def __init__(self, email, user_name, password, first_name, last_name):
        self.balance = 100
        self.register(email, user_name, password, first_name, last_name)

    # Return user profile summary
    def __repr__(self):
        return '<User: {}, Name:{} {}, E-mail: {}>'.format(self.user_name,
                                                           self.userFirstName,
                                                           self.userLastName,
                                                           self.email)

    # Register function
    def register(self, email, user_name, password, first_name, last_name):
        try:
            validate_email(email)
            self.email = email

            # only set username if it is valid
            if self.validUsername(user_name) is True:
                self.user_name = user_name

            # only set password if it is valid
            if self.validPassword(password) is True:
                self.password = password

        except Exception as exc:
            print(str(exc))
            raise ValueError()

        self.userFirstName = first_name
        self.userLastName = last_name

    # Update username
    def update_user_name(self, user_name):
        # only update username if it is valid
        if self.validUsername(user_name) is True:
            self.user_name = user_name

    # Update shipping address
    def update_shipping_address(self, shipping_address):
        # only update shipping_address if valid
        if self.validShippingAddress(shipping_address):
            self.shipping_address = shipping_address

    # Update postal code
    def update_postal_code(self, postal_code):
        # only update postal_code if valid
        if self.validPostalCode(postal_code):
            self.postal_code = postal_code

    # check if user_name is valid
    def validUsername(self, user_name):
        # initialize valid to false
        validUsername = False

        # special characters
        regex = re.compile(r'[@_!#$%^&*()<>?/\|}{~:]')

        # username len between 2 and 20 non inclusive
        if len(user_name) > 2 and len(user_name) < 20:
            # alphanumeric only
            if(regex.search(user_name) is None):
                # must begin with non space character
                if re.match(r'\w', user_name):
                    if user_name.endswith(' ') is False:
                        validUsername = True
                    else:
                        raise ValueError('Username cannot end with space')
                else:
                    raise ValueError('Username cannot begin with space')
            else:
                raise ValueError('Username cannot contain special characters')
        else:
            raise ValueError('Username must be between 2 and 20 characters')
        return validUsername

    # check if password is valid
    def validPassword(self, password):
        # initialize valid to false
        validPass = False
        # special characters
        regex = re.compile(r'[@_!#$%^&*()<>?/\|}{~:]')
        # initialize contains uppercase and lowercase to false
        containsUppercase = False
        containsLowercase = False
        # password min length 6
        if len(password) >= 6:
            # at least one special char
            if(regex.search(password) is not None):
                # at least one upper case
                for letter in password:
                    if letter.isupper():
                        containsUppercase = True
                        break
                if containsUppercase is True:
                    # at least one lower case
                    for letter in password:
                        if letter.islower():
                            containsLowercase = True
                            break
                    if containsLowercase is True:
                        validPass = True
                    else:
                        raise ValueError('Password must include lowercase')
                else:
                    raise ValueError('Password must include uppercase')
            else:
                raise ValueError('Password must include a special character')
        else:
            raise ValueError('Password too short')
        return validPass

    # validate shipping address
    def validShippingAddress(self, shipping_address):
        # initialize valid address to false
        validAddress = False
        # special characters regular expression
        special_regex = re.compile('[@_!#$%^&*()<>?/}{~:]')
        if shipping_address != '':
            # no special characters
            if (special_regex.search(shipping_address) is None):
                # only alphanumeric
                if re.search('[a-zA-Z0-9]', shipping_address):
                    validAddress = True
                else:
                    raise ValueError('Address should be alphanumeric only')
            else:
                raise ValueError('No special character in the Address')
        else:
            raise ValueError('Address should not be empty')
        return validAddress

    # validate canadian postal code
    def validPostalCode(self, postal_code):
        # initialze postal code validation to false
        validPO = False
        # regular expression for Canadian postal code
        can_po_regex = re.compile(
            r'\b(?!.{0,7}[DFIOQU])[A-VXY]\d[A-Z][^-\w\d]\d[A-Z]\d\b')
        if (can_po_regex.search(postal_code)):
            validPO = True
        else:
            raise ValueError('Invalid Canadian Postal Code')
        return validPO

# Product class with db Model parameter


class Product(db.Model):
    __tablename__ = 'product'
    # ProductId, Product UPC code the primary key of product
    # Category ID to identify and keep tracke of the product
    id = db.Column(db.Integer, primary_key=True)

    # A string value containing product name
    title = db.Column(db.String(80), nullable=False, unique=True)

    # A string value containing product description
    description = db.Column(db.String(2000), nullable=False)

    # Datetime in utc when the product or item is posted
    date_posted = db.Column(db.DateTime, nullable=False,
                            default=datetime.utcnow)

    # Datetime in utc when the product was last modified
    last_modified_date = db.Column(db.DateTime, nullable=False,
                                   default=datetime.utcnow)

    # Price of the product
    price = db.Column(db.Float, nullable=False)

    # Is the product sold or not
    sold = db.Column(db.Boolean, nullable=False, default=False)

    # Reference to owner of the product
    owner_email = db.Column(db.String(320), db.ForeignKey('user.email'))

    # Product Methods

    # Constructor
    def __init__(self, title, description, price, last_modified_date,
                 owner_email):
        self.set_title(title)
        self.set_description(description)
        self.set_price(price)
        self.set_date(last_modified_date)
        self.set_email(owner_email)

    # Setters
    # Title setter, sets title as an alphanumeric string with no spaces as
    # prefix or suffix. Title should be no longer then 80 characters.
    def set_title(self, title):
        # Check that title does not already exist
        title_exists = Product.query.filter_by(title=title).all()
        if (len(title_exists) > 0):
            raise ValueError('Title already exists')
        if (0 < len(title) <= 80):
            is_title_alphanumeric = list(map(lambda x: x[0].isalnum()
                                             or x[0].isspace(), title))
            if (all(is_title_alphanumeric)):
                if(not(title[0].isspace()) and
                   not(title[len(title) - 1].isspace())):
                    self.title = title
                else:
                    raise ValueError('Title contains space as prefix or '
                                     'suffix')
            else:
                raise ValueError('Title is not alphanumeric')
        else:
            raise ValueError('Title is longer than 80 characters')

    # Description setter, sets a description to a string between 20 characters
    # and 2000 characters.
    def set_description(self, description):
        if (len(description) <= 2000):
            if (20 <= len(description)):
                if (len(description) > len(self.title)):
                    self.description = description
                else:
                    raise ValueError('Description must be longer than title.')
            else:
                raise ValueError('Description is too short.')
        else:
            raise ValueError('Description is too long.')

    # Price setter, sets price if within range of 10 - 10000
    def set_price(self, price):
        if (10 <= price and price <= 10000):
            self.price = price
        else:
            raise ValueError('Price is out of range.')

    # Date setter, sets the date if within range of
    # 2021-01-02 and 2025-01-02
    def set_date(self, newDate):
        if(datetime(2021, 1, 2) < newDate < datetime(2024, 1, 2)):
            self.last_modified_date = newDate
        else:
            raise ValueError('Date is out of range')

    # Email setter, sets the email if email is not empty and if the owner_email
    # is valid
    def set_email(self, email):
        if(email != ''):
            # Check that email exists
            email_exists = User.query.filter_by(email=email).all()
            if (len(email_exists) > 0):
                self.owner_email = email
            else:
                raise ValueError('No matching owner emails')
        else:
            raise ValueError('Email must be not be empty')

    # Update price of a product, price cannot be decreased only increased
    def update_price(self, price):
        if ((self.price is not None) and (self.price <= price)):
            self.set_price(price)
        else:
            raise ValueError('Price can only be increased.')

    # Update a product
    def update(self, title, description, price):
        try:
            if (title != self.title):
                self.set_title(title)
            if (description != self.description):
                self.set_description(description)
            if (price != self.price):
                self.update_price(price)

            # If able to set all other values, update operation is a success
            # update date
            self.last_modified_date = datetime.now().replace(
                hour=0, minute=0, second=0, microsecond=0)
        except ValueError as exc:
            print(str(exc))
            raise ValueError('Product could not update.')

    # Print Product Name
    def __repr__(self):
        return ('<Product Title: {0}, Description:{1}, Price {2}, '
                'Last Modified Date: {3}, '
                'E-mail: {4}>'.format(self.title, self.description,
                                      self.price, self.last_modified_date,
                                      self.owner_email))

# Transaction class


class Transaction(db.Model):
    # Transaction attributes
    __tablename__ = "transaction"

    # id is the primary key used for ensuring record uniqueness in
    # the db. Should be autogenerated upon insert (incremental)
    id = db.Column(db.Integer, primary_key=True)

    # Tracking number for order. Should be autogenerated
    trasaction_number = db.Column(db.Integer, unique=True, nullable=False)

    # Email of the buyer
    user_email = db.Column(db.String(320), db.ForeignKey(
        'user.email'), nullable=False)

    # Id of the Product referenced
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'),
                           nullable=False)

    # Price of the product
    price = db.Column(db.Float, nullable=False)

    # Date of order
    date = db.Column(db.DateTime, nullable=False,
                     default=datetime.utcnow)

    # Track shipping status
    shipped = db.Column(db.Boolean, default=True, nullable=False)

    # Transaction methods

    # Initialize transaction attributes
    def __init__(self, buyer, product, date):
        self.buyer = buyer
        self.product = product
        self.date = date

    # Return string representation of a transaction
    def __repr__(self):
        return '<Transaction: {}>'.format(self.trasaction_number)

# A Class Representation of a Review for a Product


class Review(db.Model):
    # Review attributes
    __tablename__ = 'reviews'

    # An integer value, the id number of the review
    reviewId = db.Column(db.Integer, primary_key=True)

    # An integer value (1 to 5) score the product
    score = db.Column(db.Integer, unique=False, nullable=False)

    # An date value representing the day when the review was submitted
    date = db.Column(db.DateTime, nullable=False,
                     default=datetime.utcnow)

    # A string value containing the review
    review = db.Column(db.Text, unique=False, nullable=True)

    # User email reference
    user_email = db.Column(db.String(100), db.ForeignKey('user.email'),
                           nullable=False)

    # User relationship
    user = db.relationship("User", back_populates="review")

    # Simple constructor for the class
    def __init__(self, reviewId, user_email, score, review):
        self.reviewId = reviewId
        self.user_email = user_email
        self.score = score
        self.review = review

    # A method for changing the review (user_email cannot be changed)
    def changeReview(self, score, review):
        self.score = score
        self.review = review

    def __repr__(self):
        return f'Review(review={self.review}, score={self.score})'


# create database
db.create_all()

# create a user with email username and password


def create_user(email, username, password, first_name, last_name):
    # check if the email is unique
    existed = User.query.filter_by(email=email).all()
    if len(existed) > 0:
        raise ValueError('Email already in use')

    try:
        # create new user
        user = User(email=email, user_name=username, password=password,
                    first_name=first_name, last_name=last_name)
        # add new user to the database session
        db.session.add(user)
        # save the user object
        db.session.commit()
    except Exception:
        raise ValueError('Create User error')
    return True

# check password validation for login


def login_valid_password(password):
    # initialize valid to false
    validPass = False
    # special characters
    regex = re.compile(r'[@_!#$%^&*()<>?/\|}{~:]')
    # initialize contains uppercase and lowercase to false
    containsUppercase = False
    containsLowercase = False
    # password min length 6
    if len(password) >= 6:
        # at least one special char
        if(regex.search(password) is not None):
            # at least one upper case
            for letter in password:
                if letter.isupper():
                    containsUppercase = True
                    break
            if containsUppercase is True:
                # at least one lower case
                for letter in password:
                    if letter.islower():
                        containsLowercase = True
                        break
                if containsLowercase is True:
                    validPass = True
                else:
                    raise ValueError('Password must include lowercase')
            else:
                raise ValueError('Password must include uppercase')
        else:
            raise ValueError('Password must include a special character')
    else:
        raise ValueError('Password too short')
    return validPass

# R2-1: A user can log in using her/his email address and the password
# a user can log in using her/his email address and the password.


def login_user(email, password):
    # validate email before query database
    try:
        validate_email(email)
        email = email
    except EmailNotValidError as exc:
        print(str(exc))
    # validate password before query database
    login_valid_password(password)
    # query email with existing user
    user = User.query.filter_by(email=email, password=password).all()
    # check user length
    if len(user) != 1:
        return None
    return user[0]


# R3-1: A user is only able to update
# his/her user name, shipping_address, and postal_code.
# update username, shipping address and postal code


def update_user(email, choice, attribute):
    user = User.query.filter_by(email=email).all()[0]

    if choice == '1':
        user.update_user_name(attribute)
        db.session.commit()
    if choice == '2':
        user.update_shipping_address(attribute)
        db.session.commit()
    if choice == '3':
        user.update_postal_code(attribute)
        db.session.commit()


# Create a product with a title, description, price, owner email and last
# modified date


def create_product(
        title, description, price, owner_email, raise_exception=False):
    last_modified_date = datetime.now().replace(hour=0, minute=0,
                                                second=0, microsecond=0)
    try:
        product = Product(title, description, price, last_modified_date,
                          owner_email)
        db.session.add(product)
        db.session.commit()
        return True
    except ValueError as exc:
        if raise_exception:
            raise exc

        print(str(exc))
        return False

# Update a product's title, desciption, price


def update_product(old_title, new_title, description, price):
    try:
        product = Product.query.filter_by(title=old_title).all()
        if len(product) == 1:
            product[0].update(new_title, description, price)
            db.session.commit()
            return True
        else:
            print("Title does not exist")
            return False
    except Exception as exc:
        print(str(exc))
        return False

# Allow a user to place an order on products


def place_an_order(title, email, balance):
    try:
        product = Product.query.filter_by(title=title).all()
        if len(product) == 1:
            # Check that product does not belong to owner
            if product[0].owner_email != email:
                # Check that user has enough money to purchase product
                if product[0].price <= balance:
                    update_both_user_balance(product[0].price, email,
                                             product[0].owner_email)
                    product[0].sold = True
                    db.session.commit()
                    print("Thank you for your purchase!")
                else:
                    raise ValueError("Not enough money to purchase product")
            else:
                raise ValueError("Cannot purchase your own product!")
        else:
            raise ValueError("""Cannot place order for a product
                             which doesn't exist""")
            return False
    except Exception as exc:
        print(str(exc))
        return False

# Update the balance of a buyer and seller after a purchase


def update_both_user_balance(price, buyer_email, owner_email):
    buyer = User.query.filter_by(email=buyer_email).all()
    buyer[0].balance = buyer[0].balance - price
    product_owner = User.query.filter_by(email=owner_email).all()
    product_owner[0].balance = product_owner[0].balance + price
